1. npm init-y(werunitinterminalanditcreatepackage.jsonfile)
needtorun: npx tailwindcss -i ./src/main/resources/static/css/input.css -o ./src/main/resources/static/css/output.css --watch

2. we need some information in all the pages so for that we can use fragment(allow us to use inhertance concept) for that we 
use thymeleaf fragements(thymeleaf fragement need to study) fragement can be insert or replace
3. In fragement we can pass argument also(this argument can be a variable or can be a html page itself)
4. We need to apply flowbite and tailwind css to all the thymeleaf page
tailwind css comes from output.css file need to include in href as (<link rel="stylesheet" data-th-href="@{'/css/output.css'}")
and flowbite css as in <link href="" rel="stylesheet"/>

<div>--> is host tag used to mention where we show fragement

5. We can pass content also whether dynamic or static, we can pass anything dynamically like content, script,url
in the specific page and then reflect it in the base page.
Like in About page in html tag itself we use th:replace means it's content will be replace by the one it called
<html th:replace = "~{base :: parent(~{::#content},~{::title})}  in About page and make such field in 
<div id="content"><h1>Welcome to About Page</h1></div>  this content is referred above in replace part and directed to base page
& in base page we have created a fragment for html 
<html th:fragement="parent(content,title)" xmlns:th="http://www.thymeleaf.org">  and the content that we received here is
printed as <title data-th-replace="${title}">SCM</title> and so on. So what it will do first it take info from
About page pass it in #content then goes to base page it will be printed but reflected on same page we are calling.

6. If we need to check if any information is there render that if not then render default
   <th:block th:if="${content != null}">
      <section th:replace="${content}"></section>
    </th:block>
    <th:block th:unless="${content != null}">
      <section>
        <p>This is default content for the base page.</p>
      </section>
    </th:block>


    same for title also
    <th:block th:if="${title != null}">
      <title th:replace="${title}">Base Page</title>
    </th:block>
    <th:block th:if="${title == null}">
      <title>Base Page</title>
    </th:block>


7. To use dark/light icon we need to add the cdn link for font awesome    

8. In form action we mention the url like "@{'/do-register}" and the method which shows where we have to redirect the request
   method post means data will go as request body not as part of url

9. we make a UserForm.java object to receive data in /register endpoint in the controller and same used in signup page 
so data filled automatically.
We can directly use fields from object using * i.e. to access name we use th:field="*{name}"
when click signup then submit will work and sends entire data to /register endpoint in controller


NOTE: when using builder to save data from UserForm to User default value like Provider(SELF) will not get 
saved so we need to use traditional way of storing data as User user = new User(); then save each field

when we use 'RedirectAttributes redirectAttributes' then in that case we can directly access the message just by mentioning
key as "${message}" nothing else need to mention in html page

For validation purpose we add a dependency in pom.xml i.e. hibernate validator(Spring-boot-starter-validator) and used some Annotations
like @NotBlank,@Size,@Email  we need to add all these in the Entity class(UserForm.Java) we are validating
After that we need to go to the controller which handle the above Entity then use @Valid before
@ModelAttribute and also use 'BindingResult' as it is used to check for the error in the Entity.
If it has any error we can return it to same page i.e. 'signup.html' and also show the message on the same page.

To remove client side validation in form tag we add 'novalidate'

SECURING URL's/ENDPOINTS(users)-->
securing url's/endpoints which are starting with user it can only be accessible if user login
For Login we create our own login page and want only user who register only they can login.
Just by adding Spring-Security in pom.xml it will secure all pages by default and password will 
generate in console like (e6616aeb-9860-44b5-b3dd-8ee1ad580fc7) and username will be 'user' but we
don't want it, so in that case we can define/configure our own username and password in application.properties file as
like (spring.security.user.name=sarvesh) & (spring.security.user.password=sarvesh) now we have configure both
username and password to 'sarvesh'


 UserDetails user = User
        .withUsername("admin123")
        .password("admin123")
        .roles("ADMIN","USER")
        .build(); 
In above code we have not used any password encoder so we are getting below error       
java.lang.IllegalArgumentException: Given that there is no default password encoder configured, 
each password must have a password encoding prefix. Please either prefix this password with
'{noop}' or set a default password encoder in `DelegatingPasswordEncoder`.
for local testing purpose we can use 'withDefaultPasswordEncoder()' which is depricated and not recommended
if we use 'withDefaultPasswordEncoder()' then replace 'withUsername()' to 'username()'

//from DB-->
When we use DB to get user info for login, we can do this using authentication provider
there are 2 approach to do it 
1- create a separate CustomUserDetailsService implements UserDetailsService(recommende b/c clean code) we follow this
2- The entity class directly implements 'UserDetails' and provide implementation for method present in 'UserDetails'


Now on basis of above configuration/changes we are not going to configure the URL's and do security
related configuration.
After that configure security filter chain to make sure some pages are secured and some are not as 'SecurityFilterChain'
this bean is very important b/c it will help in security configuration it takes 'HttpSecurity' and this helps in
entire security configuration

formLogin(form -> form
          .loginPage("/login")             // custom login page (optional)
          .defaultSuccessUrl("/dashboard") // where to go after successful login
          .permitAll()
      )
if above user is authenticated from AuthenticationProvider then securityfilterchain start and 
if it is valid 'dashborad' will be shown if not correct detail then it will show login page itself.

FLOW-->
Login form ‚Üí AuthenticationProvider ‚Üí UserDetailsService ‚Üí Password validation
‚Üí If valid ‚Üí SecurityFilterChain allows access ‚Üí /dashboard
‚Üí If invalid ‚Üí back to /login with error.

When we use 'authenticated()' with any url then user need to login, if details correct can access allowed page or
again go to login page
httpSecurity.formLogin(Customizer.withDefaults()); it will gives default login page from spring security
here we can change formLogin configuration so that it will point to our own form

IF WE MAKE CUSTOME LOGIN FORM AND TRY TO LOGIN STEPS INVOLVED---->
when user tries to access /user/** then login form will open because not authenticated ‚úÖ
then on login page we provide username and password ‚úÖ
which goes to usernameParameter and passwordParameter ‚úÖ
then submitted at loginProcessingUrl(/authenticate) ‚úÖ
then it goes to AuthenticationProvider ‚úÖ
gets userdetailservice and all its info ‚úÖ
and compares raw password from form with the one from DB ‚úÖ
if match then AuthenticationProvider returns object held by spring context ‚úÖ
used internally for authentication and security filter chain ‚úÖ
if details correct then successForwardUrl triggers ‚úÖ
else failureForwardUrl with error query param ‚úÖ

NOTE --> 
When we make our own custom login page then in that case we need to make our own 
i.e. customize logout url(it needs to handle)
 httpSecurity.logout(formOut->{
            formOut.logoutUrl("/logout");
            //once logout return it to login success url
            formOut.logoutSuccessUrl("/login?logout=true");
         });
if we configure logout(by default logout as mentioned above) it will not work b/c CSRF protection is there
which is enable (by default) so for that we need to hit POST method. So we can disable CSRF then any http request
like get,post etc will work. We can disable CSRF as 'httpSecurity.csrf().disable();'
and also for showing error message like invalid username and password or logout success on login page we don't
need to configure anything as it will be taken care automatically by spring security we just need to mention the
paragraph for error and logout like   

<div data-th-if="${param.logout}"
              class="text-green-600 text-center px-1 py-2"
            >Logout Successfull</div>

NOW WE ARE GOING TO MAKE LOGIN WITH GOOGLE OPTION :--->(We use OAuth2 for this)

In modern application we do login with Google,Github,FaceBook because it makes login faster and user don't have 
to spent more time for login purpose
1. We need to add OAuth2 client dependency
2. OAuth already has security in it so if we want we can remove spring-security also.
3. After adding OAuth2 every thing is auto-configured, but need to add some properties to enable the auto-configuration
like what provider you use(google,github etc),it's client id, client secret(i.e. if we use Google then we need it's id and secret)
for that we need to go to google console first(google.cloud.console)
STEPS-->
go to 'google.cloud.console' -->create new project-->select the project-->menu-->click Api & services
-->'credentials and OAuth consent screen these 2 options are needed-->select external

in scopes select '/auth/userinfo.email' '/auth/userinfo.profile' &'openid'
then we create 'create credentials'-->OAuth client id(Application type-->Web Application)-->AppName then
'Authorized JavaScript origins-->click add uri and add the localhost then to which uri google will redirect, there is
one uri by default we need to mention or else it will give uri mismatch issue
'Authorized redirect URIs--> 'http://localhost:8080/login/oauth2/code/google' we can change it later if we want
it can be change in application.properties file once change we will update above url with our own custom url.
Then we go to application.properties file to configure our 'client id' & 'client secret' for OAuth2 configuration
we can mention scopes(permission) for email and profile also, else default permission will be enabled.
After doing all this go to 'SecurityConfig.java' to configure OAuth2 so that we can login using google account.
But in that case our login page that we have configured so that user can login using username & password will not appear.
So we have to login page in such way that it gives all login options i.e. login page itself so that user can login using
username & password , and also it will show all metion providers like Google, Github, FaceBook etc.
So when we make our own custom button gor Google, GIthub etc we need the url to which it direct on click
'<a href="/oauth2/authorization/google">google</a>' for google.
In order to show login page with google and github option also we replace
'httpSecurity.oauth2Login(Customizer.withDefaults());' with 'httpSecurity.oauth2Login(oauth->{
  oauth.loginPage('/login')
});

After login with Google we want to redirect to a particular page, and want to make function/method which gives User entire data
like image,pic,mail etc and we can save that in a packet with provider

DefaultOAuth2User user = (DefaultOAuth2User) authentication.getPrincipal();
        log.info(user.getName());
        user.getAttributes().forEach((key,value)->{
            log.info("KEY "+key+ "VALUE "+value);
        });
        log.info(user.getAuthorities().toString());
we use above to log user info and in order to save it to DB we fetch each field and then save it to DB.


OAUTH2 LOGIN USING GITHUB-->
We need github client-id and client-secret for that we login to the github and go to 'Developer Setting' option i.e.
Signin github-->setting-->Developer Setting-->Github Apps-->New github app(click & create) then give app name,give review
and provide homepage url(http://localhost:8080), then 'callback url' as 'http://localhost:8080/login/oauth2/code/github' then
uncheck webhook, we go to Account setting and allow email adderess->real only and profile->read & write
Working with Github is not complex but we need to make sure which provider we are working with because there is chance like
some attributes available to google might not be available in github.
SO we first check the provider we are using, based on the provider we fetch the attributes and use, but first we must create login
button for github

When we are using different provider then in that case we need to identify the provider for that we use the
'authentication and typecast it to OAuth2AuthenticationToken' and from that we fetch 'getAuthorizedClientRegistrationId'

when used google we get 'name,picture,email' and for github we get 'login,avatar_url,email'

IF WE WANT LOGGED IN USER INFO ON ALL PAGE -->
‚ÄúIf we want logged-in user info to be visible on all pages:
we make a method inside the controller and annotate it with @ModelAttribute.
It gets called automatically before any controller method,
the returned object is added to the model under the given key,
and then the controller proceeds to return the view. ‚úÖ‚Äù

‚úîÔ∏è Correct in every way.

üîÅ Behind the Scenes ‚Äì How it works:
‚úÖ You define this in the controller:

java
Copy
Edit
@ModelAttribute("loggedUser")
public User getUser(Authentication authentication) {
    return userService.getByEmail(authentication.getName());
}

Above code is only applicable if we have to return single data. But if we need to return/map multiple data then we pass model
with authentication as mention below
@ModelAttribute
public void populateCommonData(Authentication authentication, Model model) {
    User user = userService.getByEmail(authentication.getName());
    model.addAttribute("loggedUser", user);
    
    // Add more data if needed
    model.addAttribute("appVersion", "v1.2.3");
}

‚úÖ Spring automatically calls this method before each request-handling method like @GetMapping, @PostMapping, etc.

‚úÖ The return value (User object) is added to the model under the key "loggedUser".

‚úÖ The @GetMapping or @PostMapping method then runs and returns a view like "dashboard".

‚úÖ The Thymeleaf template can access ${loggedUser.name} (or whatever field you want).

If in case we want logged-in user info to be displayed on all page then we can create a root file 
marked it as @ControllerAdvice and mention below code there so it will work for all end points
@ModelAttribute
    public void loggedInUser(Model model,Authentication authentication){
        String emailOfLoggedInUser = Helper.getEmailOfLoggedInUser(authentication);
        log.info("User logged in: {} ", emailOfLoggedInUser);
         User user = userService.getUserByEmail(emailOfLoggedInUser);
        log.info(user.getAbout());
        log.info(user.getUserId());
        log.info(user.getEmail());
        log.info(user.getAuthorities().toString());
        model.addAttribute("userDetail", user);
    }